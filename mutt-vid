#!/usr/bin/env bash
# to set a fall-back default, have the following line before sourcing $db_path
#   send-hook . 'set from=default@foo.com"'
# However, if you use multiple accounts, which change with folder-hooks, then you'd have to source this fallback then $db_path every time.
# TODO: read config using flags. db_path and whether to keep a backup
# TODO: "reset" db using flags
# TODO: show duration of run

db_path=~/.mutt/sources/mutt-vid.db
db_path_prev="${db_path}.prev"

# Make a backup of the current database file
if [[ -f "$db_path" ]]; then cp "$db_path" "$db_path_prev"; fi

for directory in "$@"; do
  echo "Processing ${directory}"
  for email in "$directory/"*; do
    # Parse email lines
    #   N.B. field may be multiline, with subsequent lines starting with whitespace

    # Parse "From:"
    in_from="$(awk 'BEGIN {found="no"}; ((found=="yes") && /^\S/) || /^$/ {exit}; (found=="yes") && /^\s/ { printf "%s", $0 }; /^From:/ {found="yes"; sub(/^From: ?/, "", $0) ; printf "%s", $0}' "$email")"
    out_from="$in_from"

    # Parse "To:"
    in_to="$(awk 'BEGIN {found="no"}; ((found=="yes") && /^\S/) || /^$/ {exit}; (found=="yes") && /^\s/ { printf "%s", $0 }; /^To:/ {found="yes"; sub(/^To: ?/, "", $0) ; printf "%s", $0}' "$email")"
    # Escape it for mutt. Mutt needs \\. \\+ \\? \\\$ \\^ \` (or [.] [$])
    escaped_to="$(<<<$in_to sed -re 's/`/\\`/g' -e 's/([.+?^])/\\\\\1/g' -e 's/\$/\\\\\\$/g')"

    # Parse "Date:"
    in_date="$(awk 'BEGIN {found="no"}; ((found=="yes") && /^\S/) || /^$/ {exit}; (found=="yes") && /^\s/ { printf "%s", $0 }; /^Date:/ {found="yes"; sub(/^Date: ?/, "", $0) ; printf "%s", $0}' "$email")"
    out_date="$( date -d "$in_date" +%Y%m%d.%H%M%S )"
    # If there is no date, then just put an early date in.
    if [[ $out_date == "" ]]; then out_date="10000101.000000"; fi

    # Split To: on `,` for multiple recipients
    # TODO: what about cc's and bcc's?
    # TODO: how to run the hook for multiple recipients? Impossible? What about conflicts?
    IFS=','
    for each_to in $escaped_to; do
      # Delete whitespace (possibly leading space from `, `), then remove real name (if present) anyway
      out_to="$( <<<"$each_to" tr -d '[:space:]' | sed -r 's/.*<(.*)>/\1/' )"

      # Check that from and to exist, and there is a single @ in the to address (since this block splits on , in real names)
      if [[ "$out_from" != "" && "$out_to" != "" && "$out_to" =~ ^[^@]+@[^@]+$ ]]; then
        # Mutt format:
        #   send-hook '~t "^foo@bar.com$"' 'set from="Real Name <bar@foo.com>"'
        # Alternatively, use the following, but then you'd have to extract out the real name, rather than using the "fallback" default real name (which is also nice to leave unchanged).
        #   send-hook '~t "^foo@bar.com$"' 'set from=bar@foo.com ; set realname="Real Name"'

        # Find previous entry's line number
        prev_line="$(grep -Fnm 1 "send-hook '~t \"^${out_to}$\"' 'set from=\"" "$db_path" )"
        if [[ "$prev_line" == "" ]]; then
          new_entry="send-hook '~t \"^${out_to}$\"' 'set from=\"${out_from}\"' # $out_date"
          echo "$new_entry" >> "$db_path"
        else
          prev_num="$(<<<"$prev_line" cut -d: -f1)"
          prev_match="$(<<<"$prev_line" cut -d: -f2-)"
          prev_date="$(<<<"$prev_match" grep -Po '(?<=# )[0-9]{8}\.[0-9]{6}$')"
          if [[ $out_date > $prev_date ]]; then
            new_entry="$(<<<"send-hook '~t \"^${out_to}$\"' 'set from=\"${out_from}\"' # $out_date" sed 's/[\/&]/\\&/g')"
            sed -i "${prev_num}s/.*/$new_entry/" "$db_path"
          fi
        fi
      fi
    done
    IFS=" "
  done
done
